import { useMemo } from 'react'
import { Link } from 'react-router-dom'

import { appStore } from '../../domain/store/appStore'
import { useAppState } from '../../domain/store/useAppStore'
import { addDays, parseLocalDateString, todayLocalDateString, weekStartMonday } from '../../domain/utils/localDate'
import { getWeeklyTaskTargetPerWeekForWeekStart } from '../../domain/utils/weeklyTaskTarget'
import type { Habit, LocalDateString, OverviewMode, Score, WeeklyTask } from '../../domain/types'
import { OverviewChart } from './components/OverviewChart'
import { OverviewFilters } from './components/OverviewFilters'
import { OverviewSelectionList } from './components/OverviewSelectionList'

import sharedStyles from '../../components/ui/shared.module.css'
import styles from './OverviewPage.module.css'
import navButtonStyles from '../DailyPage/components/LeftNavButtons.module.css'

type ChartPoint = { date: LocalDateString; value: number; earned: number; maxPossible: number }

function formatDateLabel(date: LocalDateString): string {
  // Input is YYYY-MM-DD (local). Display as DD.MM.YYYY.
  const m = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(date)
  if (!m) return date
  return `${m[3]}.${m[2]}.${m[1]}`
}

function formatWeekdayShort(date: LocalDateString): string {
  const d = parseLocalDateString(date)
  // JS getDay(): 0..6 (Sun..Sat). Convert to Monday-first index: 0..6 (Mon..Sun).
  const names = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
  const idx = (d.getDay() + 6) % 7
  return names[idx] ?? ''
}

function getHabitIdsForMode(
  mode: OverviewMode,
  habits: Habit[],
  selectedCategoryId: string | null,
  selectedHabitId: string | null,
): string[] {
  if (mode === 'overall') return habits.map((h) => h.id)
  if (mode === 'priority1') return habits.filter((h) => h.priority === 1).map((h) => h.id)
  if (mode === 'priority2') return habits.filter((h) => h.priority === 2).map((h) => h.id)
  if (mode === 'priority3') return habits.filter((h) => h.priority === 3).map((h) => h.id)
  if (mode === 'category') {
    if (!selectedCategoryId) return []
    return habits.filter((h) => h.categoryId === selectedCategoryId).map((h) => h.id)
  }
  if (mode === 'habit') {
    if (!selectedHabitId) return []
    return habits.some((h) => h.id === selectedHabitId) ? [selectedHabitId] : []
  }
  return []
}

function niceTickStep(maxValue: number): number {
  const raw = maxValue / 5
  const pow10 = Math.pow(10, Math.floor(Math.log10(raw || 1)))
  const scaled = raw / pow10
  const base = scaled <= 1 ? 1 : scaled <= 2 ? 2 : scaled <= 5 ? 5 : 10
  return base * pow10
}

function buildSeries(
  dates: LocalDateString[],
  dailyScores: Record<LocalDateString, Record<string, Score>>,
  habitIds: string[],
  habitsById: Record<string, Habit>,
): ChartPoint[] {
  return dates.map((date) => {
    const scores = dailyScores[date] ?? {}

    const activeHabitIds = habitIds.filter((id) => {
      const h = habitsById[id]
      if (!h) return false
      const start = h.startDate
      return !start || date >= start
    })

    const maxPossible = activeHabitIds.length * 2
    let earned = 0
    for (const id of activeHabitIds) earned += scores[id] ?? 0

    const value = maxPossible > 0 ? earned / maxPossible : 0
    return { date, value, earned, maxPossible }
  })
}

function clampInt(value: number, min: number, max: number): number {
  const n = Number.isFinite(value) ? Math.floor(value) : min
  return Math.max(min, Math.min(max, n))
}

export function OverviewPage() {
  const state = useAppState()

  const currentWeekStart = useMemo(() => weekStartMonday(todayLocalDateString()), [])

  const anchorDate = state.uiState.overviewWindowEndDate
  const rangeDays = state.uiState.overviewRangeDays

  const { startDate, endDate } = useMemo(() => {
    if (rangeDays === 7) {
      const start = weekStartMonday(anchorDate)
      return { startDate: start, endDate: addDays(start, 6) }
    }

    const end = anchorDate
    return { startDate: addDays(end, -(rangeDays - 1)), endDate: end }
  }, [anchorDate, rangeDays])

  const weeklyTasks = useMemo(
    () => Object.values(state.weeklyTasks).slice().sort((a, b) => a.sortIndex - b.sortIndex),
    [state.weeklyTasks],
  )

  // Overview weekly summary is always Monday–Sunday for the week that contains the anchor date.
  const overviewWeekStart = useMemo(() => weekStartMonday(anchorDate), [anchorDate])
  const overviewWeekEnd = useMemo(() => addDays(overviewWeekStart, 6), [overviewWeekStart])

  const weeklyPoints = useMemo(() => {
    const byTaskDays = state.weeklyCompletionDays[overviewWeekStart] ?? {}
    const byTaskProgress = state.weeklyProgress[overviewWeekStart] ?? {}

    let earned = 0
    let max = 0

    const perTask: Array<{ task: WeeklyTask; earned: number }> = []

    for (const task of weeklyTasks) {
      const effectiveTarget = getWeeklyTaskTargetPerWeekForWeekStart(task, overviewWeekStart, currentWeekStart)
      const maxForTask = clampInt(effectiveTarget, 1, 7)
      max += maxForTask

      const days = byTaskDays[task.id]
      const fallbackCount = typeof byTaskProgress[task.id] === 'number' ? byTaskProgress[task.id] : 0
      const rawCount = Array.isArray(days) ? days.length : fallbackCount
      const earnedForTask = clampInt(rawCount, 0, maxForTask)

      earned += earnedForTask
      perTask.push({ task, earned: earnedForTask })
    }

    return { earned, max, perTask }
  }, [currentWeekStart, overviewWeekStart, state.weeklyCompletionDays, state.weeklyProgress, weeklyTasks])

  const categories = useMemo(
    () => Object.values(state.categories).sort((a, b) => a.sortIndex - b.sortIndex),
    [state.categories],
  )
  const habits = useMemo(() => {
    return Object.values(state.habits)
      .slice()
      .sort((a, b) => {
        if (a.categoryId !== b.categoryId) return a.categoryId.localeCompare(b.categoryId)
        return a.sortIndex - b.sortIndex
      })
  }, [state.habits])

  const categoryNameById = useMemo(() => {
    const m = new Map<string, string>()
    for (const c of categories) m.set(c.id, c.name)
    return m
  }, [categories])

  const dates: LocalDateString[] = useMemo(() => {
    const list: LocalDateString[] = []
    for (let i = 0; i < rangeDays; i++) list.push(addDays(startDate, i))
    return list
  }, [startDate, rangeDays])

  const habitIds = useMemo(
    () =>
      getHabitIdsForMode(
        state.uiState.overviewMode,
        habits,
        state.uiState.overviewSelectedCategoryId,
        state.uiState.overviewSelectedHabitId,
      ),
    [
      habits,
      state.uiState.overviewMode,
      state.uiState.overviewSelectedCategoryId,
      state.uiState.overviewSelectedHabitId,
    ],
  )

  const series = useMemo(
    () => buildSeries(dates, state.dailyScores, habitIds, state.habits),
    [dates, state.dailyScores, habitIds, state.habits],
  )

  const yMax = useMemo(() => {
    // Elastic overview: plot completion ratio (0..1), keep max pinned to the top.
    return 1
  }, [])

  const totalEarned = useMemo(() => series.reduce((sum, p) => sum + p.earned, 0), [series])
  const totalMaxPossible = useMemo(() => series.reduce((sum, p) => sum + p.maxPossible, 0), [series])
  const totalPct = useMemo(
    () => (totalMaxPossible > 0 ? totalEarned / totalMaxPossible : 0),
    [totalEarned, totalMaxPossible],
  )
  const avgPct = useMemo(
    () => (series.length ? series.reduce((sum, p) => sum + p.value, 0) / series.length : 0),
    [series],
  )
  const maxPossibleEnd = useMemo(() => series.at(-1)?.maxPossible ?? 0, [series])
  const activeHabitsEnd = useMemo(() => Math.floor(maxPossibleEnd / 2), [maxPossibleEnd])

  const mode = state.uiState.overviewMode

  return (
    <div className={sharedStyles.page}>
      <div className={styles.overviewLayout}>
        <main className={styles.mainCol}>
          <section className={sharedStyles.panel}>
          <div className={styles.overviewHeader}>
            <h2 className={styles.panelTitle} style={{ margin: 0 }}>
              PĀRSKATS
            </h2>

            <div className={styles.windowNav}>
              <button type="button" className={sharedStyles.smallBtn} onClick={() => appStore.actions.shiftOverviewWindow(-1)}>
                ←
              </button>
              <span className={styles.dateRangeLabel}>
                {formatDateLabel(startDate)} → {formatDateLabel(endDate)}
              </span>
              <button type="button" className={sharedStyles.smallBtn} onClick={() => appStore.actions.shiftOverviewWindow(1)}>
                →
              </button>
            </div>

            <div aria-hidden />
          </div>

          <OverviewChart series={series} yMax={yMax} />

          <div className={styles.legend}>
            <span className={styles.kpi}>
              <strong>Kopā</strong>: {Math.round(totalPct * 100)}%
            </span>
            <span className={styles.kpi}>
              <strong>Vidēji</strong>: {Math.round(avgPct * 100)}%
            </span>
            <span className={styles.kpi}>
              <strong>Maks.</strong>: {maxPossibleEnd}
            </span>
            <span className={styles.kpi}>
              <strong>Ieradumi</strong>: {activeHabitsEnd}
            </span>
          </div>
          </section>

          <section className={sharedStyles.panel}>
            <h3 className={styles.panelTitle}>Atlase</h3>

            {showCategoryList ? (
              <>
                <p className={styles.muted} style={{ marginTop: 0 }}>
                  Izvēlies kategoriju
                </p>
                <div className={styles.list}>
                  {categories.map((c) => {
                    const active = state.uiState.overviewSelectedCategoryId === c.id
                    return (
                      <div
                        key={c.id}
                        className={`${styles.listItem} ${active ? styles.listItemActive : ''}`}
                        onClick={() => appStore.actions.selectOverviewCategory(active ? null : c.id)}
                        role="button"
                        tabIndex={0}
                      >
                        <span className={styles.itemTitle}>{c.name}</span>
                      </div>
                    )
                  })}
                  {categories.length === 0 ? <p className={styles.muted}>Nav kategoriju.</p> : null}
                </div>
              </>
            ) : null}

            {showHabitList ? (
              <>
                <p className={styles.muted} style={{ marginTop: 0 }}>
                  Izvēlies ieradumu
                </p>
                <div className={styles.list}>
                  {habits.map((h) => {
                    const active = state.uiState.overviewSelectedHabitId === h.id
                    const catName = categoryNameById.get(h.categoryId) ?? '—'
                    return (
                      <div
                        key={h.id}
                        className={`${styles.listItem} ${active ? styles.listItemActive : ''}`}
                        onClick={() => appStore.actions.selectOverviewHabit(active ? null : h.id)}
                        role="button"
                        tabIndex={0}
                      >
                        <span className={styles.itemTitle}>{h.name}</span>
                        <span className={styles.muted}>{catName}</span>
                      </div>
                    )
                  })}
                  {habits.length === 0 ? <p className={styles.muted}>Nav ieradumu.</p> : null}
                </div>
              </>
            ) : (
              <p className={styles.muted} style={{ marginTop: 0 }}>
                Atlase pieejama režīmos “Kategorija” un “Ieradums”.
              </p>
            )}
          </section>
        </main>

        <aside className={styles.leftCol}>
          <section className={`${sharedStyles.panel} ${styles.sidebarPanel}`} aria-label="Pārskata sānu sadaļa">
            <div className={navButtonStyles.leftNav}>
              <Link
                to="/"
                className={navButtonStyles.navBtn}
                onClick={() => {
                  appStore.actions.setSelectedDate(todayLocalDateString())
                }}
              >
                SĀKUMA LAPA
              </Link>

              <button
                type="button"
                className={`${navButtonStyles.navBtn} ${rangeDays === 7 ? navButtonStyles.navBtnActive : ''}`}
                onClick={() => appStore.actions.setOverviewRangeDays(7)}
              >
                7 dienas
              </button>
              <button
                type="button"
                className={`${navButtonStyles.navBtn} ${rangeDays === 30 ? navButtonStyles.navBtnActive : ''}`}
                onClick={() => appStore.actions.setOverviewRangeDays(30)}
              >
                30 dienas
              </button>
            </div>

            <div className={styles.sidebarStack}>

              <div className={styles.weeklyPanel} aria-label="Nedēļas punkti">
                <div className={styles.weeklyHeader}>
                  <h3 className={styles.panelTitle} style={{ margin: 0 }}>
                    Nedēļa
                  </h3>
                  <div className={styles.weeklyRange}>
                    {formatDateLabel(overviewWeekStart)}–{formatDateLabel(overviewWeekEnd)}
                  </div>
                </div>

                {weeklyTasks.length === 0 ? (
                  <p className={styles.muted} style={{ margin: 0 }}>
                    Nav nedēļas uzdevumu.
                  </p>
                ) : (
                  <>
                    <div className={styles.weeklySummaryRow}>
                      <div className={styles.progressBar} aria-hidden>
                        <div
                          className={styles.progressFill}
                          style={{
                            width:
                              weeklyPoints.max > 0
                                ? `${Math.round((weeklyPoints.earned / weeklyPoints.max) * 100)}%`
                                : '0%',
                          }}
                        />
                      </div>

                      <div className={styles.pointsText}>
                        {weeklyPoints.earned} / {weeklyPoints.max}
                      </div>
                    </div>

                    <div className={styles.weeklyTaskBreakdown}>
                      {weeklyPoints.perTask.map(({ task, earned }) => (
                        <div key={task.id} className={styles.weeklyTaskRow}>
                          <span className={styles.weeklyTaskName} title={task.name}>
                            {task.name}
                          </span>
                          <span className={styles.muted}>
                            {earned}/{clampInt(getWeeklyTaskTargetPerWeekForWeekStart(task, overviewWeekStart, currentWeekStart), 1, 7)}
                          </span>
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>

              <hr className={styles.sidebarDivider} />

              <OverviewFilters mode={mode} />
            </div>
          </section>
        </aside>
      </div>
    </div>
  )
}

export default OverviewPage
